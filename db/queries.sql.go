// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getProfile = `-- name: getProfile :many
SELECT users.user_id,
    users.quote,
    users.date as roll_date,
    users.favorite,
    characters.id,
    characters.image,
    characters.name,
    characters.date,
    characters.type
FROM users
    INNER JOIN characters ON characters.user_id = users.user_id
WHERE users.user_id = $1
`

type getProfileRow struct {
	Date     time.Time     `json:"date"`
	RollDate time.Time     `json:"roll_date"`
	Name     string        `json:"name"`
	Image    string        `json:"image"`
	Quote    string        `json:"quote"`
	Type     string        `json:"type"`
	Favorite sql.NullInt64 `json:"favorite"`
	ID       int64         `json:"id"`
	UserID   int64         `json:"user_id"`
}

func (q *Queries) getProfile(ctx context.Context, userID int64) ([]getProfileRow, error) {
	rows, err := q.query(ctx, q.getProfileStmt, getProfile, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProfileRow
	for rows.Next() {
		var i getProfileRow
		if err := rows.Scan(
			&i.UserID,
			&i.Quote,
			&i.RollDate,
			&i.Favorite,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
