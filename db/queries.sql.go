// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getProfile = `-- name: getProfile :many
SELECT users.user_id,
    users.quote,
    users.date as roll_date,
    users.favorite,
    users.tokens,
    users.anilist_url,
    characters.id,
    characters.image,
    characters.name,
    characters.date,
    characters.type
FROM users
    INNER JOIN characters ON characters.user_id = users.user_id
WHERE users.user_id = $1
`

type getProfileRow struct {
	UserID     int64         `json:"user_id"`
	Quote      string        `json:"quote"`
	RollDate   time.Time     `json:"roll_date"`
	Favorite   sql.NullInt64 `json:"favorite"`
	Tokens     int32         `json:"tokens"`
	AnilistUrl string        `json:"anilist_url"`
	ID         int64         `json:"id"`
	Image      string        `json:"image"`
	Name       string        `json:"name"`
	Date       time.Time     `json:"date"`
	Type       string        `json:"type"`
}

func (q *Queries) getProfile(ctx context.Context, userID int64) ([]getProfileRow, error) {
	rows, err := q.query(ctx, q.getProfileStmt, getProfile, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getProfileRow
	for rows.Next() {
		var i getProfileRow
		if err := rows.Scan(
			&i.UserID,
			&i.Quote,
			&i.RollDate,
			&i.Favorite,
			&i.Tokens,
			&i.AnilistUrl,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByAnilist = `-- name: getUserByAnilist :one
SELECT users.user_id,
    users.quote,
    users.date as roll_date,
    users.favorite,
    users.tokens,
    users.anilist_url
FROM users
WHERE users.anilist_url = $1
`

type getUserByAnilistRow struct {
	UserID     int64         `json:"user_id"`
	Quote      string        `json:"quote"`
	RollDate   time.Time     `json:"roll_date"`
	Favorite   sql.NullInt64 `json:"favorite"`
	Tokens     int32         `json:"tokens"`
	AnilistUrl string        `json:"anilist_url"`
}

func (q *Queries) getUserByAnilist(ctx context.Context, anilistUrl string) (getUserByAnilistRow, error) {
	row := q.queryRow(ctx, q.getUserByAnilistStmt, getUserByAnilist, anilistUrl)
	var i getUserByAnilistRow
	err := row.Scan(
		&i.UserID,
		&i.Quote,
		&i.RollDate,
		&i.Favorite,
		&i.Tokens,
		&i.AnilistUrl,
	)
	return i, err
}
